<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PWNED</title>

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <link rel="stylesheet"
        href="https://code.jquery.com/ui/1.13.3/themes/base/jquery-ui.css" />

  <style>
    body  { font-family: sans-serif; margin: 20px; }
    #board {
       width: 720px;
       max-width: 90vw; 
       margin-top: 10px;
    }
    #board .white-1e1d7 { background:#eeffd2; }  /* light square  */
    #board .black-3c85d { background:#769656; }  /* dark square   */
    #title {
      font-size: 20px;
      font-variant: small-caps; 
    }
    #version {
      font-size: small;
    }
  </style>
</head>
<body>
  <span id='title'>pwned</span>
  <span id='version'> v0.13</span>
  <div id="board"></div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.3/jquery-ui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <script>
    const HUMAN_COLOR  = 'white';
    // const START_FEN    = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    const START_FEN = '3k4/pppppppp/pppppppp/pppppppp/pppppppp/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    const ENGINE_DEPTH = 8;
    const ENGINE_SKILL = 4;

    const piece_sets = Array();
    piece_sets[1] = 'https://cdn.jsdelivr.net/gh/lichess-org/lila/public/piece/alpha/{piece}.svg';
    piece_sets[2] = 'https://cdn.jsdelivr.net/gh/oakmac/chessboardjs/website/img/chesspieces/alpha/{piece}.png';
    piece_sets[3] = 'https://lichess.org/assets/piece/maestro/{piece}.svg';
    piece_sets[4] = 'https://cdn.jsdelivr.net/gh/oakmac/chessboardjs/website/img/chesspieces/wikipedia/{piece}.png';
    const PIECES_URL = piece_sets[2];

    const PIECE_CODES  = ['wK','wQ','wR','wB','wN','wP',
                          'bK','bQ','bR','bB','bN','bP'];

    /* -------- build one-time base-64 cache -------- */

    //
    //  When using chessboard.js for displaying the board, we give it a URL
    //  to retrieve the piece images from. However, it will fetch these images
    //  every time the board is updated. 
    //
    //  This is ok if the image host has the right cache settings, but many
    //  do not. A work around is a poor-man's cash, achieved by loading all
    //  the images into a list, because if the browswer sees a URL it's 
    //  already storing somewhere, it won't reload.  However, this internal
    //  cache can be emptied willy nilly.
    //
    //  The reliable fix is to take advantage of the fact that the pieceTheme
    //  property of chessboard.js can also be a function  (in addition to a
    //  template URL. 
    //

    async function build_image_cache () {
      const cache = {};
      await Promise.all(PIECE_CODES.map(pc => new Promise(async (ok, err) => {
        try {
          const url  = PIECES_URL.replace('{piece}', pc);
          const blob = await fetch(url).then(r => r.blob());
          const fr   = new FileReader();
          fr.onload  = () => { cache[pc] = fr.result; ok(); };
          fr.onerror = err;
          fr.readAsDataURL(blob);
        } catch (e) { err(e); }
      })));
      return cache;
    }

    async function create_stockfish_engine () {
      // there are newer stockfish versions than 10.0.2 but this one is notable 
      // for compatability across browsers
      const url  = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.min.js';
      const code = await (await fetch(url)).text();
      return new Worker(URL.createObjectURL(new Blob([code], { type: 'application/javascript' })));
    }

    (async () => {
      /* 0. cache the 12 piece images (data-URIs) */
      const imgCache = await build_image_cache();

      /* 1. game state */
      const game = new Chess(START_FEN);

      /* 2. visual board */
      const board = Chessboard('board', {
        position: START_FEN,
        orientation: HUMAN_COLOR,
        draggable: true,
        pieceTheme: code => imgCache[code],   // â† data-URI source
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: () => board.position(game.fen())
      });

      /* 3. engine */
      const engine      = await create_stockfish_engine();
      let   engineReady = false;

      engine.onmessage = (e) => {
        const line = typeof e === 'object' ? e.data : e;
        // console.log(line);
        if (line === 'uciok') {
          engineReady = true;
          maybeEngineMove();
        } else if (line.startsWith('bestmove')) {
          const [ , uci ] = line.split(' ');
          apply_engine_move(uci);
        } else if (line.startsWith('info')) {
          const m = (/ score (?:cp|mate) (-?\d+)/.exec(line))[1];
          console.log(m);
        }
      };

      engine.postMessage('uci');
      engine.postMessage('setoption name Skill Level value ' + ENGINE_SKILL);
      engine.postMessage('ucinewgame');

      /* --- drag helpers --- */
      function onDragStart (source, piece) {
        if (game.game_over()) return false;
        const turn = game.turn() === 'w' ? 'white' : 'black';
        if (turn !== HUMAN_COLOR) return false;
        if (HUMAN_COLOR === 'white' && piece.startsWith('b')) return false;
        if (HUMAN_COLOR === 'black' && piece.startsWith('w')) return false;
      }

      function onDrop(source, target) {
        const p      = game.get(source);
        const promo  = p?.type === 'p' && (target[1] === '8' || target[1] === '1');
        const move   = game.move({ from: source, to: target,
                                   promotion: promo ? 'q' : undefined });
        if (!move) return 'snapback';
        maybeEngineMove();
      }

      /* --- engine helpers --- */
      function maybeEngineMove() {
        if (!engineReady || game.game_over()) return;
        if ((game.turn() === 'w' ? 'white' : 'black') === HUMAN_COLOR) return;
        engine.postMessage('position fen ' + game.fen());
        engine.postMessage('go depth ' + ENGINE_DEPTH);
      }

      function apply_engine_move(uci) {
        const move = game.move({
          from: uci.slice(0,2),
          to:   uci.slice(2,4),
          promotion: uci.length === 5 ? uci[4] : undefined
        });
        if (move) board.position(game.fen());
        maybeEngineMove();
      }

      if (HUMAN_COLOR === 'black') {
        const t = setInterval(() => {
          if (engineReady) { clearInterval(t); maybeEngineMove(); }
        }, 30);
      }
    })();
  </script>
</body>
</html>
