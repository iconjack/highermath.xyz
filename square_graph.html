<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Functional Digraph G_{p,n}: x ↦ x^n (mod p)</title>
<style>
  :root{
    --bg:#0b0f14;
    --fg:#d9e1ee;
    --cycle:#ffd166;        /* warm for cycles */
    --tree:#4cc9f0;         /* internal tree nodes */
    --term:#f72585;         /* terminal nodes (indegree 0) */
    --edge:#93a1b0;
    --edge-cycle:#ffad3b;
    --hull:#ffffff22;
    --hull-fill:#ffffff08;  /* subtle tint */
    --panel:#0f141b;
    --accent:#5eead4;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  header,footer{
    background:linear-gradient(180deg,#0f141b,#0b0f14);
    padding:10px 12px;
    border-bottom:1px solid #11161f;
  }
  header{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label{font-size:13px;opacity:.9}
  input[type=number]{width:7.5em}
  .btn{
    background:#17202b;color:var(--fg);border:1px solid #1d2733;border-radius:8px;
    padding:6px 10px;cursor:pointer
  }
  .btn:hover{border-color:#2a3747}
  .btn.on{outline:2px solid var(--accent);outline-offset:1px}
  .group{display:inline-flex;gap:6px;align-items:center;background:#0f141b;padding:6px 8px;border-radius:10px;border:1px solid #1b2531}
  .grow{flex:1}
  #wrap{position:relative;height:calc(100% - 120px)}
  #svg{width:100%;height:100%;background:var(--bg);user-select:none;touch-action:none}
  .node text{fill:#0b0f14;font-weight:600;pointer-events:none}
  .node.cycle circle{fill:var(--cycle)}
  .node.tree  circle{fill:var(--tree)}
  .node.term  circle{fill:var(--term)}
  .edge{stroke:var(--edge);stroke-width:1.25px;fill:none;opacity:.9}
  .edge.cycle{stroke:var(--edge-cycle);opacity:.98}
  .hull{stroke:var(--hull);stroke-dasharray:6 6;stroke-width:1.2;fill:var(--hull-fill)}
  .status{font-variant-numeric:tabular-nums}
  .msg{padding:14px 16px;color:#ddd}
  .tip{opacity:.7;font-size:12px}
  #tooltip{
    position:absolute;pointer-events:none;background:#111827; color:#e5e7eb; border:1px solid #222c3a;
    padding:6px 8px; border-radius:8px; font-size:12px; white-space:nowrap; transform:translate(8px,8px); display:none
  }
  .slider{width:150px}
  .kbd{background:#11161f;border:1px solid #1f2937;border-bottom-width:2px;padding:1px 5px;border-radius:6px;font-size:12px}
</style>
</head>
<body>
  <header>
    <div class="group">
      <label for="pInput">p:</label>
      <input id="pInput" type="number" min="3" step="1" value="101"/>
      <button class="btn" id="randPrime">Random prime ≤ 997</button>
    </div>
    <div class="group" id="expGroup" role="group" aria-label="exponent">
      <span>n:</span>
      <button class="btn exp" data-n="2">2</button>
      <button class="btn exp" data-n="3">3</button>
      <button class="btn exp" data-n="4">4</button>
      <button class="btn exp" data-n="5">5</button>
    </div>
    <div class="group">
      <button class="btn" id="generate">Generate</button>
      <button class="btn" id="export">Export SVG</button>
    </div>
    <div class="group">
      <label for="scaleSlider">Scale</label>
      <input id="scaleSlider" class="slider" type="range" min="0.3" max="2.5" step="0.01" value="1"/>
      <label for="rSlider">Node size</label>
      <input id="rSlider" class="slider" type="range" min="6" max="26" step="1" value="12"/>
    </div>
    <div class="grow"></div>
    <div class="tip">Pan: drag • Zoom: wheel • Reset: double-click • Switch n: <span class="kbd">2</span>/<span class="kbd">3</span>/<span class="kbd">4</span>/<span class="kbd">5</span></div>
  </header>

  <div id="wrap">
    <svg id="svg" viewBox="-600 -350 1200 700">
      <defs>
        <marker id="arrow" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M0,0 L8,4 L0,8 Z" fill="currentColor"></path>
        </marker>
      </defs>
      <g id="viewport"></g>
    </svg>
    <div id="tooltip"></div>
  </div>

  <footer>
    <div id="status" class="status">p=…  n=…  nodes=…  cycles=…</div>
    <div id="err" class="msg" style="display:none"></div>
  </footer>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const primesUpTo997 = (()=>{ // deterministic primes ≤ 997
    const ps=[2]; for(let x=3;x<=997;x+=2){let ok=true;for(const p of ps){if(p*p>x)break;if(x%p===0){ok=false;break}} if(ok)ps.push(x)} return ps;
  })();

  const svg = document.getElementById('svg');
  const vp  = document.getElementById('viewport');
  const pInput = document.getElementById('pInput');
  const statusEl = document.getElementById('status');
  const errEl = document.getElementById('err');
  const tip = document.getElementById('tooltip');
  const scaleSlider = document.getElementById('scaleSlider');
  const rSlider = document.getElementById('rSlider');

  let state = {
    p: 101,
    n: 2,
    nodeR: 12,
    scale: 1,
    tx: 0, ty: 0,
  };

  // ---------- Math core ----------
  function modPow(base, exp, mod){
    let res = 1 % mod, b = base % mod, e = exp;
    while(e>0){ if(e & 1) res = (res * b) % mod; b = (b * b) % mod; e >>= 1; }
    return res;
  }
  function buildMapping(p, n){
    const f = new Array(p);
    for(let x=1; x<=p-1; x++){
      let y = modPow(x, n, p);
      if(y===0) y = 1; // keep inside domain even if p composite
      f[x] = y;
    }
    return f;
  }
  function indegrees(f, p){
    const indeg = new Array(p).fill(0);
    for(let x=1;x<=p-1;x++) indeg[f[x]]++;
    return indeg;
  }
  function decompose(f, p){
    const seen = new Array(p).fill(0);
    const onstack = new Array(p).fill(0);
    const components = [];
    for(let s=1; s<=p-1; s++){
      if(seen[s]) continue;
      let x = s;
      while(!seen[x]){ seen[x]=1; onstack[x]=1; x = f[x]; }
      if(onstack[x]){
        const cyc = []; let y = x;
        do { cyc.push(y); y = f[y]; } while(y!==x && cyc.length<=p);
        for(const v of cyc) onstack[v]=0;

        const rev = Array.from({length:p}, ()=>[]);
        for(let u=1; u<=p-1; u++){ const v=f[u]; if(v!==u) rev[v].push(u); }
        const trees = new Map();
        for(const c of cyc){
          const list = []; const st=[...rev[c]]; const vis=new Set();
          while(st.length){
            const u = st.pop();
            if(vis.has(u) || cyc.includes(u)) continue;
            vis.add(u); list.push(u);
            for(const w of rev[u]) if(!vis.has(w)) st.push(w);
          }
          trees.set(c, list);
        }
        components.push({cycle:cyc, trees});
      }
      x = s; while(onstack[x]){ onstack[x]=0; x=f[x]; }
    }
    return components;
  }
  function classifyNodes(f, p, components){
    const indeg = indegrees(f,p);
    const classOf = new Array(p).fill("term");
    const inCycle = new Array(p).fill(false);
    for(const comp of components) for(const v of comp.cycle) inCycle[v]=true;
    for(let i=1;i<=p-1;i++){
      classOf[i] = inCycle[i] ? "cycle" : (indeg[i]>0 ? "tree" : "term");
    }
    return { indeg, classOf, inCycle };
  }

  // ---------- Anti-overlap relaxer ----------
  function relaxPositions(pos, nodeR, iterations=3) {
    const keys = [...pos.keys()];
    const minD = nodeR * 2.6; // bigger gap
    for (let it = 0; it < iterations; it++) {
      for (let i = 0; i < keys.length; i++) {
        const ai = keys[i], a = pos.get(ai);
        for (let j = i + 1; j < keys.length; j++) {
          const bj = keys[j], b = pos.get(bj);
          const dx = b.x - a.x, dy = b.y - a.y;
          const d = Math.hypot(dx, dy);
          if (d > 0 && d < minD) {
            const push = (minD - d) * 0.5;
            const ux = dx / d, uy = dy / d;
            a.x -= ux * push; a.y -= uy * push;
            b.x += ux * push; b.y += uy * push;
          }
        }
      }
    }
  }

  // ---------- Layout (cycle ring + fanned trees) ----------
  function layoutComponent(comp, f, opts){
    const { nodeR } = opts;
    const cycle = comp.cycle.slice();
    const L = cycle.length;

    // Larger ring so adjacent cycle labels breathe
    const minArc = 2.8 * nodeR;                 // arc length per cycle node
    const ringR_by_arc  = (minArc * L) / (2 * Math.PI);
    const ringR_by_size = Math.max(48, 3.2 * nodeR * Math.sqrt(L));
    const baseCycleR = Math.max(ringR_by_arc, ringR_by_size);

    const angleStep = (2*Math.PI)/Math.max(1, L);
    const pos = new Map();

    // place cycle nodes
    for(let i=0;i<L;i++){
      const theta = i*angleStep;
      pos.set(cycle[i], {x: baseCycleR*Math.cos(theta), y: baseCycleR*Math.sin(theta), theta});
    }

    // reverse adjacency limited to the component
    const rev = new Map();
    for(const v of cycle) rev.set(v, []);
    for(const [root, list] of comp.trees.entries()){
      for(const u of list){
        const v = f[u];
        if(!rev.has(v)) rev.set(v, []);
        rev.get(v).push(u);
        if(!rev.has(u)) rev.set(u, []);
      }
    }

    // trees
    const depthMap = new Map();
    for(let i=0;i<L;i++){
      const root = cycle[i];
      const rootPos = pos.get(root);
      const children = (rev.get(root) || []).slice().sort((a,b)=>a-b);

      const q = [];
      for(const c of children){ q.push({u:c,depth:1}); depthMap.set(c,1); }

      const fanCount = Math.max(1, children.length);
      const spread = Math.min(Math.PI/3.0, 0.14 + fanCount*0.075);
      const baseTheta = rootPos.theta;
      let index = 0;
      const assignedAngle = new Map();
      for(const c of children){
        const frac = (fanCount===1)?0:(index/(fanCount-1)-0.5);
        assignedAngle.set(c, baseTheta + frac*spread);
        index++;
      }

      while(q.length){
        const {u,depth} = q.shift();
        const parent = f[u];
        let theta = assignedAngle.get(u);
        if(theta===undefined){
          const parAngle = assignedAngle.get(parent);
          theta = (parAngle!==undefined)? parAngle : baseTheta;
          assignedAngle.set(u, theta);
        }
        const radialStep = Math.max(30, nodeR * 3.2);  // push levels farther out
        const dist = baseCycleR + depth*radialStep;
        const jitter = ((u*9301+49297)%233)/233 - 0.5;
        const rtheta = theta + 0.05*jitter;
        pos.set(u, {x: dist*Math.cos(rtheta), y: dist*Math.sin(rtheta), theta:rtheta});

        const kids = (rev.get(u) || []).slice().sort((a,b)=>a-b);
        const kspread = Math.min(0.8, 0.14 + kids.length*0.055);
        for(let k=0;k<kids.length;k++){
          const w = kids[k];
          if(depthMap.has(w)) continue;
          const frac = (kids.length===1)?0:(k/(kids.length-1)-0.5);
          assignedAngle.set(w, rtheta + frac*kspread);
          depthMap.set(w, depth+1);
          q.push({u:w, depth:depth+1});
        }
      }
    }

    // relax to remove residual overlaps
    relaxPositions(pos, nodeR, 3);

    // bound radius
    let rMax = 0;
    for(const {x,y} of pos.values()){
      const r = Math.hypot(x,y) + nodeR + 6;
      if(r>rMax) rMax = r;
    }
    return { pos, radius: Math.max(rMax, baseCycleR+nodeR+8) };
  }

  // ---------- Convex hull ----------
  function convexHull(points){
    if(points.length<=1) return points.slice();
    const pts = points.slice().sort((a,b)=> a.x===b.x ? a.y-b.y : a.x-b.x);
    const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
    const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
    const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
    upper.pop(); lower.pop();
    return lower.concat(upper);
  }

  // ---------- Component packing ----------
  function packComponents(layouts, cellGap=50){
    const comps = layouts.slice().sort((a,b)=> b.radius - a.radius);
    const n = comps.length;
    const cols = Math.ceil(Math.sqrt(n));
    const rows = Math.ceil(n/cols);
    const maxR = comps.reduce((m,c)=>Math.max(m,c.radius), 0);
    const cell = 2*maxR + cellGap;
    const placements = [];
    for(let i=0;i<n;i++){
      const col = i % cols, row = Math.floor(i/cols);
      placements.push({cx:(col-(cols-1)/2)*cell, cy:(row-(rows-1)/2)*cell});
    }
    return placements;
  }

  // ---------- Drawing helpers ----------
  function clearSVG(){ while(vp.firstChild) vp.removeChild(vp.firstChild); }

  function autoTextSize(label, r){
    const len = String(label).length;
    const base = r*1.35;
    if(len===1) return base;
    if(len===2) return base*0.95;
    if(len===3) return base*0.80;
    return Math.max(9, base*0.70);
  }

  function drawSelfLoop(container, x, y, r, color){
    const loopR = Math.max(7, 0.95*r);
    const offset = r + loopR + 4;
    const phi = Math.PI/4; // tilt away gently
    const cx = x + offset * Math.cos(phi);
    const cy = y - offset * Math.sin(phi);
    const a0 = Math.PI*0.2, a1 = Math.PI*1.9;
    const p0 = `${cx + loopR*Math.cos(a0)},${cy + loopR*Math.sin(a0)}`;
    const p1 = `${cx + loopR*Math.cos(a1)},${cy + loopR*Math.sin(a1)}`;
    const largeArc = (a1-a0) > Math.PI ? 1 : 0;
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute("d", `M ${p0} A ${loopR} ${loopR} 0 ${largeArc} 1 ${p1}`);
    path.setAttribute("class","edge cycle");
    path.setAttribute("stroke", color);
    path.setAttribute("fill","none");
    path.setAttribute("marker-end","url(#arrow)");
    container.appendChild(path);
  }

  function drawArrow(uPos, vPos, nodeR, isCycleEdge){
    const dx = vPos.x - uPos.x, dy = vPos.y - uPos.y;
    const L = Math.hypot(dx,dy);
    if(L < 1e-6) return;

    const nx = dx / L, ny = dy / L;
    const start = {x: uPos.x + nx*nodeR, y: uPos.y + ny*nodeR};
    const end   = {x: vPos.x - nx*(nodeR+3), y: vPos.y - ny*(nodeR+3)};

    // If the drawable segment is too short, render a small curved arc instead of a stubby line
    const minStraight = Math.max(10, nodeR*0.8);
    const segLen = Math.hypot(end.x-start.x, end.y-start.y);

    const stroke = isCycleEdge? "var(--edge-cycle)" : "var(--edge)";

    if(segLen < minStraight){
      const midx = (start.x + end.x)/2, midy = (start.y + end.y)/2;
      const px = -ny, py = nx; // perpendicular
      const bulge = Math.max(8, nodeR*0.9);
      const cx = midx + px * bulge;
      const cy = midy + py * bulge;
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", `M ${start.x},${start.y} Q ${cx},${cy} ${end.x},${end.y}`);
      path.setAttribute("class","edge" + (isCycleEdge?" cycle":""));
      path.setAttribute("stroke", stroke);
      path.setAttribute("fill","none");
      path.setAttribute("marker-end","url(#arrow)");
      vp.appendChild(path);
    } else {
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", start.x); line.setAttribute("y1", start.y);
      line.setAttribute("x2", end.x);   line.setAttribute("y2", end.y);
      line.setAttribute("class","edge" + (isCycleEdge?" cycle":""));
      line.setAttribute("stroke", stroke);
      line.setAttribute("marker-end","url(#arrow)");
      vp.appendChild(line);
    }
  }

  // ---------- Main draw ----------
  function drawGraph(p, n){
    clearSVG();
    const nodeR = state.nodeR|0;

    if(!(Number.isInteger(p) && p>=3 && p<=2000)){
      errEl.style.display="block";
      errEl.textContent = "Enter an integer p ≥ 3 (≤ 2000 for performance).";
      statusEl.textContent = `p=—  n=${n}  nodes=—  cycles=—`;
      return;
    }
    errEl.style.display="none";

    const f = buildMapping(p,n);
    const comps = decompose(f,p);
    const { classOf, inCycle } = classifyNodes(f,p,comps);

    // local layouts
    const layouts = comps.map(comp => ({comp, ...layoutComponent(comp, f, {nodeR})}));
    const placements = packComponents(layouts, 60);

    // assemble absolute positions and draw hulls
    let compIdx = 0;
    const allPos = new Map();
    for(const L of layouts){
      const place = placements[compIdx++];
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("transform", `translate(${place.cx},${place.cy})`);
      vp.appendChild(g);

      const pts=[]; for(const pt of L.pos.values()) pts.push({x:pt.x,y:pt.y});
      const hull = convexHull(pts);
      if(hull.length>=3){
        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute("points", hull.map(p=>`${p.x},${p.y}`).join(" "));
        poly.setAttribute("class","hull");
        g.appendChild(poly);
      }
      for(const [v,pt] of L.pos.entries()){
        allPos.set(v, {x:pt.x + place.cx, y:pt.y + place.cy});
      }
    }

    // edges
    for(let u=1; u<=p-1; u++){
      const v = f[u];
      const pu = allPos.get(u), pv = allPos.get(v);
      if(!pu || !pv) continue;

      if(u===v){
        // self-loop (e.g., 1 → 1 when n=2)
        const tone = inCycle[u] ? getComputedStyle(document.documentElement).getPropertyValue('--edge-cycle') : getComputedStyle(document.documentElement).getPropertyValue('--edge');
        drawSelfLoop(vp, pu.x, pu.y, nodeR, tone || "#ffad3b");
      } else {
        const isCycleEdge = inCycle[u] && inCycle[v] && (f[u]===v);
        drawArrow(pu, pv, nodeR, isCycleEdge);
      }
    }

    // nodes
    for(let i=1;i<=p-1;i++){
      const P = allPos.get(i); if(!P) continue;
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("class", `node ${classOf[i]}`);
      g.setAttribute("transform", `translate(${P.x},${P.y})`);
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("r", nodeR);
      c.setAttribute("stroke", "#0b0f14aa");
      c.setAttribute("stroke-width","1.2");
      g.appendChild(c);
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("text-anchor","middle");
      t.setAttribute("dominant-baseline","central");
      t.setAttribute("font-size", String(Math.round(autoTextSize(i,nodeR))));
      t.textContent = String(i);
      g.appendChild(t);

      // tooltip
      g.addEventListener('pointerenter', ()=>{ tip.style.display='block'; tip.textContent = `i = ${i}\nnext = i^${n} mod p = ${f[i]}\nclass = ${classOf[i]}`; });
      g.addEventListener('pointermove', (e)=>{
        const rect = svg.getBoundingClientRect();
        tip.style.left = (e.clientX - rect.left + 10) + 'px';
        tip.style.top  = (e.clientY - rect.top  + 10) + 'px';
      });
      g.addEventListener('pointerleave', ()=>{ tip.style.display='none'; });

      vp.appendChild(g);
    }

    statusEl.textContent = `p=${p}  n=${n}  nodes=${p-1}  cycles=${comps.length}`;
  }

  // ---------- Pan / Zoom / Reset ----------
  function applyView(){ vp.setAttribute("transform", `translate(${state.tx},${state.ty}) scale(${state.scale})`); }
  let isPanning=false, panStart=null, startTX=0, startTY=0;
  svg.addEventListener('pointerdown', e=>{ svg.setPointerCapture(e.pointerId); isPanning=true; panStart={x:e.clientX,y:e.clientY}; startTX=state.tx; startTY=state.ty; });
  svg.addEventListener('pointermove', e=>{
    if(!isPanning) return;
    const dx=e.clientX-panStart.x, dy=e.clientY-panStart.y;
    state.tx=startTX+dx; state.ty=startTY+dy; applyView();
  });
  svg.addEventListener('pointerup', ()=>{ isPanning=false; });
  svg.addEventListener('pointerleave', ()=>{ isPanning=false; });

  svg.addEventListener('wheel', e=>{
    e.preventDefault();
    const rect = svg.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    const prev = state.scale;
    const next = Math.min(8, Math.max(0.2, prev * Math.exp(-e.deltaY * 0.0015)));
    const vx = (cx - state.tx)/prev, vy = (cy - state.ty)/prev;
    state.tx = cx - vx*next; state.ty = cy - vy*next; state.scale = next;
    scaleSlider.value = String(Math.max(0.3, Math.min(2.5, next)));
    applyView();
  }, {passive:false});

  svg.addEventListener('dblclick', ()=>{ state.scale=1; state.tx=0; state.ty=0; scaleSlider.value="1"; applyView(); });

  // ---------- Controls ----------
  document.getElementById('generate').addEventListener('click', ()=>{
    state.p = parseInt(pInput.value,10);
    drawGraph(state.p, state.n);
  });
  document.getElementById('randPrime').addEventListener('click', ()=>{
    const p = primesUpTo997[Math.floor(Math.random()*primesUpTo997.length)];
    pInput.value = String(p); state.p = p; drawGraph(state.p, state.n);
  });
  document.getElementById('expGroup').addEventListener('click', (e)=>{
    const btn = e.target.closest('.exp'); if(!btn) return;
    for(const b of document.querySelectorAll('.exp')) b.classList.remove('on');
    btn.classList.add('on'); state.n = parseInt(btn.dataset.n,10);
    drawGraph(state.p, state.n);
  });
  scaleSlider.addEventListener('input', ()=>{ state.scale = parseFloat(scaleSlider.value); applyView(); });
  rSlider  .addEventListener('input', ()=>{ state.nodeR = parseInt(rSlider.value,10); drawGraph(state.p, state.n); });
  window.addEventListener('keydown', (e)=>{
    if(['2','3','4','5'].includes(e.key)){
      state.n = parseInt(e.key,10);
      for(const b of document.querySelectorAll('.exp')) b.classList.toggle('on', parseInt(b.dataset.n,10)===state.n);
      drawGraph(state.p, state.n);
    }
  });

  // ---------- Export SVG ----------
  document.getElementById('export').addEventListener('click', ()=>{
    const clone = svg.cloneNode(true);
    const src = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([src], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.download = `G_pn_p${state.p}_n${state.n}.svg`; a.href = url;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // ---------- Init ----------
  function init(){
    for(const b of document.querySelectorAll('.exp')) b.classList.toggle('on', parseInt(b.dataset.n,10)===state.n);
    state.p = parseInt(pInput.value,10);
    state.nodeR = parseInt(rSlider.value,10);
    drawGraph(state.p, state.n);
    applyView();
  }
  init();

})();
</script>
</body>
</html>
