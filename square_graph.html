<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functional Digraph Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/webcola/dist/cola.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e8e8e8;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .controls {
            background: #1a1a1a;
            padding: 12px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        label {
            font-size: 13px;
            color: #999;
            font-weight: 500;
        }
        input[type="number"] {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            width: 80px;
            font-size: 14px;
        }
        button {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e8e8e8;
            padding: 6px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s;
        }
        button:hover { background: #3a3a3a; border-color: #555; }
        button.active {
            background: #0066ff;
            border-color: #0088ff;
            color: #fff;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        svg.panning { cursor: grabbing; }
        .status {
            background: #1a1a1a;
            padding: 10px 20px;
            border-top: 1px solid #333;
            font-size: 12px;
            color: #888;
            font-family: 'Courier New', monospace;
        }
        .tooltip {
            position: absolute;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .node { cursor: pointer; transition: opacity 0.2s; }
        .node:hover { opacity: 0.85; }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="pInput">p:</label>
            <input type="number" id="pInput" value="13" min="3">
        </div>
        <div class="control-group">
            <label>n:</label>
            <button class="n-btn active" data-n="2">2</button>
            <button class="n-btn" data-n="3">3</button>
            <button class="n-btn" data-n="4">4</button>
            <button class="n-btn" data-n="5">5</button>
        </div>
        <button id="generateBtn">Generate</button>
        <button id="randomBtn">Random Prime ≤ 997</button>
        <div class="control-group">
            <label for="scaleInput">Scale:</label>
            <input type="number" id="scaleInput" value="1" min="0.1" max="5" step="0.1">
        </div>
        <button id="exportBtn">Export SVG</button>
    </div>
    
    <div class="canvas-container" id="canvasContainer">
        <svg id="svg"></svg>
        <div class="tooltip" id="tooltip"></div>
    </div>
    
    <div class="status" id="status">Ready</div>

    <script>
        let state = {
            p: 13,
            n: 2,
            graph: null,
            layout: null,
            transform: { x: 0, y: 0, scale: 1 },
            isPanning: false,
            panStart: { x: 0, y: 0 }
        };
        
        const CONFIG = {
            nodeRadius: 18,
            cycleRadius: 100,
            treeLayerSpacing: 65,
            componentPadding: 120,
            colors: {
                cycle: '#ff6b6b',
                internal: '#4ecdc4',
                terminal: '#a8dadc',
                cycleEdge: '#ff8585',
                treeEdge: '#555'
            }
        };
        
        const PRIMES = [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
        
        function init() {
            document.getElementById('generateBtn').onclick = generate;
            document.getElementById('randomBtn').onclick = () => {
                const prime = PRIMES[Math.floor(Math.random() * PRIMES.length)];
                document.getElementById('pInput').value = prime;
                generate();
            };
            document.getElementById('exportBtn').onclick = exportSVG;
            document.getElementById('scaleInput').oninput = () => {
                const scale = parseFloat(document.getElementById('scaleInput').value);
                if (scale > 0) {
                    state.transform.scale = scale;
                    updateTransform();
                }
            };
            
            document.querySelectorAll('.n-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.n-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.n = parseInt(btn.dataset.n);
                    generate();
                };
            });
            
            document.getElementById('pInput').onkeypress = e => {
                if (e.key === 'Enter') generate();
            };
            
            setupInteractions();
            generate();
        }
        
        function setupInteractions() {
            const svg = document.getElementById('svg');
            
            svg.onmousedown = e => {
                if (e.target.classList.contains('node')) return;
                state.isPanning = true;
                state.panStart = { x: e.clientX - state.transform.x, y: e.clientY - state.transform.y };
                svg.classList.add('panning');
            };
            
            svg.onmousemove = e => {
                if (!state.isPanning) return;
                state.transform.x = e.clientX - state.panStart.x;
                state.transform.y = e.clientY - state.panStart.y;
                updateTransform();
            };
            
            const endPan = () => {
                state.isPanning = false;
                svg.classList.remove('panning');
            };
            svg.onmouseup = endPan;
            svg.onmouseleave = endPan;
            
            svg.onwheel = e => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(5, state.transform.scale * delta));
                
                const rect = svg.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                state.transform.x = mx - (mx - state.transform.x) * (newScale / state.transform.scale);
                state.transform.y = my - (my - state.transform.y) * (newScale / state.transform.scale);
                state.transform.scale = newScale;
                
                document.getElementById('scaleInput').value = newScale.toFixed(1);
                updateTransform();
            };
            
            svg.ondblclick = () => {
                state.transform = { x: 0, y: 0, scale: 1 };
                document.getElementById('scaleInput').value = '1';
                updateTransform();
            };
        }
        
        function updateTransform() {
            const g = document.getElementById('mainGroup');
            if (g) {
                g.setAttribute('transform', 
                    `translate(${state.transform.x},${state.transform.y}) scale(${state.transform.scale})`);
            }
        }
        
        function generate() {
            state.p = parseInt(document.getElementById('pInput').value);
            
            if (!state.p || state.p < 3) {
                document.getElementById('status').textContent = 'Error: p must be ≥ 3';
                document.getElementById('svg').innerHTML = '';
                return;
            }
            
            state.graph = buildGraph(state.p, state.n);
            state.layout = computeLayout(state.graph, state.p);
            render();
        }
        
        function buildGraph(p, n) {
            const nodes = [];
            const edges = [];
            const next = new Map();
            
            for (let i = 1; i < p; i++) {
                let nextVal = modPow(i, n, p);
                if (nextVal === 0) nextVal = 1;
                next.set(i, nextVal);
                nodes.push({ id: i, next: nextVal });
            }
            
            const cycles = findCycles(p, next);
            const inCycle = new Set(cycles.flat());
            const indegree = computeIndegree(p, next);
            
            nodes.forEach(node => {
                if (inCycle.has(node.id)) {
                    node.type = 'cycle';
                } else if (indegree.get(node.id) > 0) {
                    node.type = 'internal';
                } else {
                    node.type = 'terminal';
                }
            });
            
            for (let i = 1; i < p; i++) {
                const nextNode = next.get(i);
                if (i === 1 && nextNode === 1) continue;
                
                const isSelfLoop = i === nextNode;
                const isCycleEdge = inCycle.has(i) && inCycle.has(nextNode);
                edges.push({ from: i, to: nextNode, selfLoop: isSelfLoop, cycleEdge: isCycleEdge });
            }
            
            return { nodes, edges, cycles, next, indegree, inCycle };
        }
        
        function modPow(base, exp, mod) {
            let result = 1;
            base = base % mod;
            while (exp > 0) {
                if (exp % 2 === 1) result = (result * base) % mod;
                exp = Math.floor(exp / 2);
                base = (base * base) % mod;
            }
            return result;
        }
        
        function findCycles(p, next) {
            const cycles = [];
            const visited = new Set();
            
            for (let start = 1; start < p; start++) {
                if (visited.has(start)) continue;
                
                const path = [];
                const pathSet = new Set();
                let curr = start;
                let steps = 0;
                
                while (!visited.has(curr) && !pathSet.has(curr) && steps < p) {
                    path.push(curr);
                    pathSet.add(curr);
                    curr = next.get(curr);
                    steps++;
                }
                
                path.forEach(v => visited.add(v));
                
                if (pathSet.has(curr)) {
                    const cycleStart = path.indexOf(curr);
                    cycles.push(path.slice(cycleStart));
                }
            }
            
            return cycles;
        }
        
        function computeIndegree(p, next) {
            const indegree = new Map();
            for (let i = 1; i < p; i++) indegree.set(i, 0);
            for (let i = 1; i < p; i++) {
                const n = next.get(i);
                indegree.set(n, indegree.get(n) + 1);
            }
            return indegree;
        }
        
        function computeLayout(graph, p) {
            const positions = new Map();
            const components = [];
            
            graph.cycles.forEach(cycle => {
                const component = { cycle: [], trees: [] };
                const angleStep = (2 * Math.PI) / cycle.length;
                
                cycle.forEach((nodeId, idx) => {
                    const angle = idx * angleStep - Math.PI / 2;
                    positions.set(nodeId, {
                        x: CONFIG.cycleRadius * Math.cos(angle),
                        y: CONFIG.cycleRadius * Math.sin(angle)
                    });
                    component.cycle.push(nodeId);
                });
                
                const processed = new Set(cycle);
                cycle.forEach(rootId => {
                    const tree = buildTree(rootId, processed, graph, p);
                    if (tree.length > 0) {
                        component.trees.push({ root: rootId, nodes: tree });
                        layoutTree(tree, rootId, positions, graph, p);
                    }
                });
                
                components.push(component);
            });
            
            positionComponents(components, positions);
            applyColaLayout(graph, positions, p);
            
            return { positions, components };
        }
        
        function buildTree(rootId, processed, graph, p) {
            const tree = [];
            const queue = [rootId];
            
            while (queue.length > 0) {
                const current = queue.shift();
                for (let i = 1; i < p; i++) {
                    if (processed.has(i)) continue;
                    if (graph.next.get(i) === current) {
                        tree.push(i);
                        processed.add(i);
                        queue.push(i);
                    }
                }
            }
            
            return tree;
        }
        
        function layoutTree(tree, rootId, positions, graph, p) {
            if (tree.length === 0) return;
            
            const rootPos = positions.get(rootId);
            const layers = buildLayers(tree, rootId, graph, p);
            
            layers.forEach((layer, dist) => {
                const radius = CONFIG.cycleRadius + (dist + 1) * CONFIG.treeLayerSpacing;
                const baseAngle = Math.atan2(rootPos.y, rootPos.x);
                const spread = Math.min(Math.PI / 2.5, (layer.length + 1) * 0.4);
                const step = layer.length > 1 ? spread / (layer.length - 1) : 0;
                
                layer.forEach((nodeId, idx) => {
                    const offset = (idx - (layer.length - 1) / 2) * step;
                    const angle = baseAngle + offset;
                    positions.set(nodeId, {
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                });
            });
        }
        
        function buildLayers(tree, rootId, graph, p) {
            const layers = [];
            const layerMap = new Map();
            
            tree.forEach(nodeId => {
                let dist = 0;
                let curr = nodeId;
                const seen = new Set();
                
                while (curr !== rootId && !seen.has(curr) && dist < p) {
                    seen.add(curr);
                    curr = graph.next.get(curr);
                    dist++;
                }
                
                if (!layers[dist]) layers[dist] = [];
                layers[dist].push(nodeId);
            });
            
            return layers;
        }
        
        function positionComponents(components, positions) {
            const gridCols = Math.ceil(Math.sqrt(components.length));
            
            components.forEach((comp, idx) => {
                const row = Math.floor(idx / gridCols);
                const col = idx % gridCols;
                
                const allNodes = [...comp.cycle, ...comp.trees.flatMap(t => t.nodes)];
                const bounds = getBounds(allNodes, positions);
                
                const offsetX = col * (bounds.width + CONFIG.componentPadding) - bounds.minX;
                const offsetY = row * (bounds.height + CONFIG.componentPadding) - bounds.minY;
                
                allNodes.forEach(id => {
                    const pos = positions.get(id);
                    pos.x += offsetX;
                    pos.y += offsetY;
                });
            });
        }
        
        function getBounds(nodes, positions) {
            const xs = nodes.map(id => positions.get(id).x);
            const ys = nodes.map(id => positions.get(id).y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };
        }
        
        function applyColaLayout(graph, positions, p) {
            if (typeof cola === 'undefined') return;
            
            const colaNodes = graph.nodes.map(node => {
                const pos = positions.get(node.id);
                return { 
                    id: node.id,
                    x: pos.x, 
                    y: pos.y,
                    width: CONFIG.nodeRadius * 2.5,
                    height: CONFIG.nodeRadius * 2.5
                };
            });
            
            const colaLinks = graph.edges.map(edge => ({
                source: edge.from - 1,
                target: edge.to - 1
            }));
            
            cola.d3adaptor()
                .nodes(colaNodes)
                .links(colaLinks)
                .avoidOverlaps(true)
                .handleDisconnected(true)
                .linkDistance(70)
                .start(10, 10, 10);
            
            colaNodes.forEach(node => {
                positions.set(node.id, { x: node.x, y: node.y });
            });
        }
        
        function render() {
            const svg = document.getElementById('svg');
            svg.innerHTML = '';
            
            const rect = svg.getBoundingClientRect();
            const allPos = Array.from(state.layout.positions.values());
            const bounds = {
                minX: Math.min(...allPos.map(p => p.x)) - 80,
                maxX: Math.max(...allPos.map(p => p.x)) + 80,
                minY: Math.min(...allPos.map(p => p.y)) - 80,
                maxY: Math.max(...allPos.map(p => p.y)) + 80
            };
            
            const contentW = bounds.maxX - bounds.minX;
            const contentH = bounds.maxY - bounds.minY;
            const scale = Math.min(rect.width / contentW, rect.height / contentH) * 0.85;
            
            state.transform = {
                x: (rect.width - contentW * scale) / 2 - bounds.minX * scale,
                y: (rect.height - contentH * scale) / 2 - bounds.minY * scale,
                scale
            };
            document.getElementById('scaleInput').value = scale.toFixed(1);
            
            const defs = createDefs();
            svg.appendChild(defs);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.id = 'mainGroup';
            g.setAttribute('transform', 
                `translate(${state.transform.x},${state.transform.y}) scale(${state.transform.scale})`);
            
            state.layout.components.forEach(comp => drawComponentHull(g, comp));
            state.graph.edges.forEach(edge => drawEdge(g, edge));
            state.graph.nodes.forEach(node => drawNode(g, node));
            
            svg.appendChild(g);
            
            document.getElementById('status').textContent = 
                `p=${state.p} | n=${state.n} | nodes=${state.p-1} | cycles=${state.graph.cycles.length}`;
        }
        
        function createDefs() {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrow');
            marker.setAttribute('markerWidth', '8');
            marker.setAttribute('markerHeight', '8');
            marker.setAttribute('refX', '7');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            poly.setAttribute('points', '0 0, 8 3, 0 6');
            poly.setAttribute('fill', CONFIG.colors.treeEdge);
            marker.appendChild(poly);
            defs.appendChild(marker);
            return defs;
        }
        
        function drawComponentHull(g, comp) {
            const allNodes = [...comp.cycle, ...comp.trees.flatMap(t => t.nodes)];
            const points = allNodes.map(id => state.layout.positions.get(id));
            const hull = convexHull(points);
            
            if (hull.length > 2) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M' + hull.map(p => `${p.x},${p.y}`).join('L') + 'Z');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#444');
                path.setAttribute('stroke-width', '1.5');
                path.setAttribute('stroke-dasharray', '6,4');
                path.setAttribute('opacity', '0.25');
                g.appendChild(path);
            }
        }
        
        function drawEdge(g, edge) {
            const fromPos = state.layout.positions.get(edge.from);
            const toPos = state.layout.positions.get(edge.to);
            const color = edge.cycleEdge ? CONFIG.colors.cycleEdge : CONFIG.colors.treeEdge;
            
            if (edge.selfLoop) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const r = CONFIG.nodeRadius * 1.4;
                path.setAttribute('d', 
                    `M ${fromPos.x + CONFIG.nodeRadius},${fromPos.y} 
                     A ${r},${r} 0 1,1 ${fromPos.x},${fromPos.y - CONFIG.nodeRadius}`);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '2');
                path.setAttribute('marker-end', 'url(#arrow)');
                g.appendChild(path);
            } else {
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const ux = dx / dist;
                    const uy = dy / dist;
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromPos.x + ux * CONFIG.nodeRadius);
                    line.setAttribute('y1', fromPos.y + uy * CONFIG.nodeRadius);
                    line.setAttribute('x2', toPos.x - ux * CONFIG.nodeRadius);
                    line.setAttribute('y2', toPos.y - uy * CONFIG.nodeRadius);
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrow)');
                    g.appendChild(line);
                }
            }
        }
        
        function drawNode(g, node) {
            const pos = state.layout.positions.get(node.id);
            const color = CONFIG.colors[node.type];
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', pos.x);
            circle.setAttribute('cy', pos.y);
            circle.setAttribute('r', CONFIG.nodeRadius);
            circle.setAttribute('fill', color);
            circle.setAttribute('stroke', '#222');
            circle.setAttribute('stroke-width', '2.5');
            circle.classList.add('node');
            
            circle.onmouseenter = e => {
                const tooltip = document.getElementById('tooltip');
                const typeLabel = node.type === 'cycle' ? 'Cycle node' : 
                                 node.type === 'internal' ? 'Internal tree node' : 'Terminal node';
                tooltip.innerHTML = `i = ${node.id}<br>next = ${node.id}^${state.n} mod ${state.p} = ${node.next}<br>${typeLabel}`;
                tooltip.style.display = 'block';
                tooltip.style.left = e.pageX + 12 + 'px';
                tooltip.style.top = e.pageY + 12 + 'px';
            };
            circle.onmouseleave = () => {
                document.getElementById('tooltip').style.display = 'none';
            };
            
            g.appendChild(circle);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'central');
            text.setAttribute('fill', '#000');
            text.setAttribute('font-size', CONFIG.nodeRadius * 0.75);
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('pointer-events', 'none');
            text.textContent = node.id;
            g.appendChild(text);
        }
        
        function convexHull(points) {
            if (points.length < 3) return points;
            
            points = [...points].sort((a, b) => a.x - b.x || a.y - b.y);
            const lower = [];
            for (const p of points) {
                while (lower.length >= 2) {
                    const a = lower[lower.length - 2];
                    const b = lower[lower.length - 1];
                    if ((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x) <= 0) {
                        lower.pop();
                    } else break;
                }
                lower.push(p);
            }
            
            const upper = [];
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                while (upper.length >= 2) {
                    const a = upper[upper.length - 2];
                    const b = upper[upper.length - 1];
                    if ((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x) <= 0) {
                        upper.pop();
                    } else break;
                }
                upper.push(p);
            }
            
            upper.pop();
            lower.pop();
            const hull = lower.concat(upper);
            
            const cx = hull.reduce((s, p) => s + p.x, 0) / hull.length;
            const cy = hull.reduce((s, p) => s + p.y, 0) / hull.length;
            
            return hull.map(p => {
                const dx = p.x - cx;
                const dy = p.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const factor = dist > 0 ? (dist + 40) / dist : 1;
                return { x: cx + dx * factor, y: cy + dy * factor };
            });
        }
        
        function exportSVG() {
            const svg = document.getElementById('svg').cloneNode(true);
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            const blob = new Blob([svgStr], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `digraph_p${state.p}_n${state.n}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        init();
    </script>
</body>
</html>